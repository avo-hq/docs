"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const chalk_1 = __importDefault(require("chalk"));
const dotenv_1 = __importDefault(require("dotenv"));
const buildPluginEsbuild_1 = require("./build/buildPluginEsbuild");
const resolver_1 = require("./resolver");
const utils_1 = require("./utils");
const debug = require('debug')('vite:config');
async function resolveConfig(mode, configPath) {
    const start = Date.now();
    const cwd = process.cwd();
    let config;
    let resolvedPath;
    let isTS = false;
    if (configPath) {
        resolvedPath = path_1.default.resolve(cwd, configPath);
    }
    else {
        const jsConfigPath = path_1.default.resolve(cwd, 'vite.config.js');
        if (fs_extra_1.default.existsSync(jsConfigPath)) {
            resolvedPath = jsConfigPath;
        }
        else {
            const tsConfigPath = path_1.default.resolve(cwd, 'vite.config.ts');
            if (fs_extra_1.default.existsSync(tsConfigPath)) {
                isTS = true;
                resolvedPath = tsConfigPath;
            }
        }
    }
    if (!resolvedPath) {
        // load environment variables
        return {
            env: loadEnv(mode, cwd)
        };
    }
    try {
        if (!isTS) {
            try {
                config = require(resolvedPath);
            }
            catch (e) {
                if (!/Cannot use import statement|Unexpected token 'export'/.test(e.message)) {
                    throw e;
                }
            }
        }
        if (!config) {
            // 2. if we reach here, the file is ts or using es import syntax.
            // transpile es import syntax to require syntax using rollup.
            const rollup = require('rollup');
            const esbuildPlugin = await buildPluginEsbuild_1.createEsbuildPlugin(false, {});
            // use node-resolve to support .ts files
            const nodeResolve = require('@rollup/plugin-node-resolve').nodeResolve({
                extensions: resolver_1.supportedExts
            });
            const bundle = await rollup.rollup({
                external: (id) => (id[0] !== '.' && !path_1.default.isAbsolute(id)) ||
                    id.slice(-5, id.length) === '.json',
                input: resolvedPath,
                treeshake: false,
                plugins: [esbuildPlugin, nodeResolve]
            });
            const { output: [{ code }] } = await bundle.generate({
                exports: 'named',
                format: 'cjs'
            });
            config = await loadConfigFromBundledFile(resolvedPath, code);
        }
        // normalize config root to absolute
        if (config.root && !path_1.default.isAbsolute(config.root)) {
            config.root = path_1.default.resolve(path_1.default.dirname(resolvedPath), config.root);
        }
        // resolve plugins
        if (config.plugins) {
            for (const plugin of config.plugins) {
                config = resolvePlugin(config, plugin);
            }
        }
        config.env = loadEnv(mode, config.root || cwd);
        debug(`config resolved in ${Date.now() - start}ms`);
        config.__path = resolvedPath;
        return config;
    }
    catch (e) {
        console.error(chalk_1.default.red(`[vite] failed to load config from ${resolvedPath}:`));
        console.error(e);
        process.exit(1);
    }
}
exports.resolveConfig = resolveConfig;
async function loadConfigFromBundledFile(fileName, bundledCode) {
    const extension = path_1.default.extname(fileName);
    const defaultLoader = require.extensions[extension];
    require.extensions[extension] = (module, filename) => {
        if (filename === fileName) {
            ;
            module._compile(bundledCode, filename);
        }
        else {
            defaultLoader(module, filename);
        }
    };
    delete require.cache[fileName];
    const raw = require(fileName);
    const config = raw.__esModule ? raw.default : raw;
    require.extensions[extension] = defaultLoader;
    return config;
}
function resolvePlugin(config, plugin) {
    return {
        ...config,
        alias: {
            ...plugin.alias,
            ...config.alias
        },
        transforms: [...(config.transforms || []), ...(plugin.transforms || [])],
        resolvers: [...(config.resolvers || []), ...(plugin.resolvers || [])],
        configureServer: [].concat(config.configureServer || [], plugin.configureServer || []),
        vueCompilerOptions: {
            ...config.vueCompilerOptions,
            ...plugin.vueCompilerOptions
        },
        vueCustomBlockTransforms: {
            ...config.vueCustomBlockTransforms,
            ...plugin.vueCustomBlockTransforms
        },
        rollupInputOptions: {
            ...config.rollupInputOptions,
            ...plugin.rollupInputOptions
        },
        rollupOutputOptions: {
            ...config.rollupOutputOptions,
            ...plugin.rollupOutputOptions
        }
    };
}
function loadEnv(mode, root) {
    debug(`env mode: ${mode}`);
    const envFiles = [
        /** default file */ `.env`,
        /** local file */ `.env.local`,
        /** mode file */ `.env.${mode}`,
        /** mode local file */ `.env.${mode}.local`
    ];
    const env = {};
    for (const file of envFiles) {
        const path = utils_1.lookupFile(root, [file], true);
        if (path) {
            const result = dotenv_1.default.config({
                debug: !!process.env.DEBUG || undefined,
                path
            });
            if (result.error) {
                throw result.error;
            }
            Object.assign(env, result.parsed);
        }
    }
    debug(`env: %O`, env);
    return env;
}
//# sourceMappingURL=config.js.map